## HTTP 特点
超文本传输协议的缩写，是用于从服务器端传输超文本到本地浏览器的传输协议。
1. 无状态，每次请求都是独立，无关的，默认不需要保留状态信息
2. 基于请求/响应模型的协议
3. 简单快速
4. 可靠传输

### HTTP 缺点：
**无状态**
当请求仅仅为了获取一些数据，不需要保持连接上下文信息时，无状态可以减少开销。

但是在长连接场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。

**明文传输**

协议里的报文不使用二进制，而是文本形式，报文信息暴露给外界，容易被攻击。

其中 ```wifi陷阱``` 就是利用此特点，诱导用户连接热点，通过抓取你的流量，从而窃取用户敏感信息。

**队头阻塞问题**
当 http 开启长连接时，共用一个 TCP ，同一时刻只能处理一个请求。当请求耗时过长，会导致其他请求处于阻塞状态。
```！
并发连接解决，目前浏览器对于一个域名允许分配多个长连接，如Chrome 中是 6 个
```

## HTTP 的请求方法
在 http/1.1 规定了以下请求方法
- GET:获取资源
- HEAD：获取资源元信息
- POST：提交数据
- PUT：修改数据
- DELETE：删除资源
- CONNECT：建立连接隧道，用于代理服务器
- OPTIONS：列出可对资源实行的请求方法，用来跨域请求
- TRACE：追踪请求-响应的传输路径

## GET 和 POST 区别
- GET ：有缓存，请求长度受限，参数放在 URL 中，不安全，幂等(幂等表示执行相同的操作，结果也是相同的)
- POST：更多的编码类型，安全
```!
从 TCP 角度，GET 会把请求报文一次性发出，而 POST 会分为两个 TCP 数据包，先发 header 部分，服务器响应100，再发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)
```
## HTTP 常见状态码

大致区分 ：

1. 1**-信息提示
2. 2**-请求成功
3. 3**请求重定向
4. 4**请求错误
5. 5**服务器错误

几个常见的状态码，我们需要牢记

1. 200-请求成功，服务器已成功处理了请求
2. 400-请求错误，服务器不理解请求的语法
3. 403-服务器拒绝请求
4. 404-找不到
5. 500-服务器内部错误，甩锅后端

## HTTP 缓存
**强缓存**和**协商缓存**

先通过```Cache-Control``` 验证强缓存是否可用

- 如果强缓存可用，那么直接用
- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的```If-Modified-Since``` 或者```If-None-Match``` 这些条件请求字段检查资源是否更新,如果缓存有效会返回 304,如果有更新则返回200

## 了解浏览器的缓存机制吗？

web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是**强缓存策略**和**协商缓存策略**。

**协商缓存**：当使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。
如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。

**区别**：强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

**强缓存策略**：使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必向服务器发送请求。强缓存策略可以通过两种方式来设置，分别为 http 头部信息中的 **Expires 和 Cache-Control**。

Expires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性。它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如我们可以通过设置 max-age 来指定资源能够被缓存的时间
的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires
来说，这种方式更加有效一些。常用的还有比如 private ，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。还有如 n
o-store ，用来指定资源不能够被缓存，no-cache 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。

通常来说设置一种就行了，两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。

## session 与 cookie
1，session 在服务器端，cookie 在客户端（浏览器）
2，session 默认被存在在服务器的一个文件里（不是内存）
3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）
4，session 可以放在 文件、数据库、或内存中都可以。
5，用户验证这种场合一般会用 session 因此，维持一个会话的核心就是客户端的唯一标识，即 session id

[session 与 cookie](https://www.zhihu.com/question/19786827/answer/21643186)
链接：
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
## UDP 和 TCP

UDP:	协议面向无连接，不需要在传输数据前先连接对方，缺点：因此他具有不可靠性，不保证数据有序且不丢失的传递到对端，优点：相比TCP更轻便高效

TCP:	断开和连接都需要先握手，并在数据传输过程中，通过算法来保证数据的可靠性

## TCP的三次握手和四次挥手




## http协议详解



当我们在浏览器地址栏输入我们要访问的 URL 后，浏览器会分析出URL上面的域名，然后通过DNS服务器解析出域名映射的IP地址，浏览器根据查询到的IP地址与Web服务器进行通信.

而用于客户端与服务器之间的通信协议就是我们今天要研究的 HTTP 协议。如果想了解从输入 URL 到页面呈现背后发生的故事，可以戳[这里](./HTTP.md)

http是TCP/IP协议族的一部分



## HTTP 是无状态协议

**为了更快地处理大量事务，确保协议的可伸缩性， HTTP 协议被设计成无状态协议。**

HTTP 协议自身不会对请求和响应之间的通信状态进行保存。任何两次请求之间都没有依赖关系。直观地说，就是每个请求都是独立的，与前面的请求和后面的请求都是没有直接联系的。协议本身并不保留之前一切的请求或 响应报文的信息，换言之协议对于发送过的请求或者响应都不做持久化处理。




<Vssue/>