(window.webpackJsonp=window.webpackJsonp||[]).push([[221],{939:function(e,a,t){"use strict";t.r(a);var r=t(13),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"优化前端资源加载-3-进一步控制-js-大小"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化前端资源加载-3-进一步控制-js-大小"}},[e._v("#")]),e._v(" 优化前端资源加载 3 - 进一步控制 JS 大小")]),e._v(" "),t("p",[e._v("前面已经介绍了一些优化资源加载的方法，这一小节是这个主题的最后一部分，内容更为深入，主要介绍如何把我们的 JS 代码文件变得更小。")]),e._v(" "),t("h2",{attrs:{id:"按需加载模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#按需加载模块"}},[e._v("#")]),e._v(" 按需加载模块")]),e._v(" "),t("p",[e._v("前面讲述了如何把大的代码文件进行拆分，抽离出多个页面共享的部分，但是当你的 Web 应用是单个页面，并且极其复杂的时候，你会发现有一些代码并不是每一个用户都需要用到的。你可能希望将这一部分代码抽离出去，仅当用户真正需要用到时才加载，这个时候就需要用到 webpack 提供的一个优化功能 —— 按需加载代码模块。")]),e._v(" "),t("p",[e._v("在 webpack 的构建环境中，要按需加载代码模块很简单，遵循 ES 标准的动态加载语法 "),t("a",{attrs:{href:"https://github.com/tc39/proposal-dynamic-import",target:"_blank",rel:"noopener noreferrer"}},[e._v("dynamic-import"),t("OutboundLink")],1),e._v(" 来编写代码即可，webpack 会自动处理使用该语法编写的模块：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象\n// 注释 webpackChunkName: "lodash" 可以用于指定 chunk 的名称，在输出文件时有用\nimport(/* webpackChunkName: "lodash" */ \'lodash\').then((_) => { \n  console.log(_.lash([1, 2, 3])) // 打印 3\n})\n\n')])])]),t("p",[e._v("注意一下，如果你使用了 "),t("a",{attrs:{href:"http://babeljs.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babel"),t("OutboundLink")],1),e._v(" 的话，还需要 "),t("a",{attrs:{href:"https://babeljs.io/docs/plugins/syntax-dynamic-import/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Syntax Dynamic Import"),t("OutboundLink")],1),e._v(" 这个 Babel 插件来处理 "),t("code",[e._v("import()")]),e._v(" 这种语法。")]),e._v(" "),t("p",[e._v("由于动态加载代码模块的语法依赖于 promise，对于低版本的浏览器，需要添加 promise 的 "),t("a",{attrs:{href:"https://github.com/stefanpenner/es6-promise",target:"_blank",rel:"noopener noreferrer"}},[e._v("polyfill"),t("OutboundLink")],1),e._v(" 后才能使用。")]),e._v(" "),t("p",[e._v("如上的代码，webpack 构建时会自动把 lodash 模块分离出来，并且在代码内部实现动态加载 lodash 的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以 "),t("code",[e._v("import")]),e._v(" 方法是返回一个 promise 来获取动态加载的模块内容。")]),e._v(" "),t("p",[t("code",[e._v("import")]),e._v(" 后面的注释 "),t("code",[e._v('webpackChunkName: "lodash"')]),e._v(" 用于告知 webpack 所要动态加载模块的名称。我们在 webpack 配置中添加一个 "),t("code",[e._v("output.chunkFilename")]),e._v(" 的配置：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("output: {\n  path: path.resolve(__dirname, 'dist'),\n  filename: '[name].[hash:8].js',\n  chunkFilename: '[name].[hash:8].js' // 指定分离出来的代码文件的名称\n},\n\n")])])]),t("p",[e._v("这样就可以把分离出来的文件名称用 lodash 标识了，如下图：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/3/19/1623c0221f015c5d?w=1148&h=216&f=png&s=86642",alt:"dynamic-import"}})]),e._v(" "),t("p",[e._v("如果没有添加注释 "),t("code",[e._v('webpackChunkName: "lodash"')]),e._v(" 以及 "),t("code",[e._v("output.chunkFilename")]),e._v(" 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别。")]),e._v(" "),t("h2",{attrs:{id:"tree-shaking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking"}},[e._v("#")]),e._v(" Tree shaking")]),e._v(" "),t("p",[e._v("Tree shaking 这个术语起源于 ES2015 模块打包工具 "),t("a",{attrs:{href:"https://github.com/rollup/rollup",target:"_blank",rel:"noopener noreferrer"}},[e._v("rollup"),t("OutboundLink")],1),e._v("，依赖于 ES2015 模块系统中的"),t("a",{attrs:{href:"http://exploringjs.com/es6/ch_modules.html#static-module-structure",target:"_blank",rel:"noopener noreferrer"}},[e._v("静态结构特性"),t("OutboundLink")],1),e._v("，可以移除 JavaScript 上下文中的未引用代码，删掉用不着的代码，能够有效减少 JS 代码文件的大小。拿官方文档的例子来说明一下。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// src/math.js\nexport function square(x) {\n  return x * x;\n}\n\nexport function cube(x) {\n  return x * x * x;\n}\n\n// src/index.js\nimport { cube } from './math.js' // 在这里只是引用了 cube 这个方法\n\nconsole.log(cube(3))\n\n")])])]),t("p",[e._v("如果整个项目代码只是上述两个文件，那么很明显，"),t("code",[e._v("square")]),e._v(" 这个方法是未被引用的代码，是可以删掉的。在 webpack 中，只有启动了 JS 代码压缩功能（即使用 uglify）时，会做 Tree shaking 的优化。webpack 4.x 需要指定 mode 为 production，而 webpack 3.x 的话需要配置 UglifyJsPlugin。启动了之后，构建出来的结果就会移除 "),t("code",[e._v("square")]),e._v(" 的那一部分代码了。")]),e._v(" "),t("p",[e._v("如果你在项目中使用了 "),t("a",{attrs:{href:"http://babeljs.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babel"),t("OutboundLink")],1),e._v(" 的话，要把 Babel 解析模块语法的功能关掉，在 "),t("code",[e._v(".babelrc")]),e._v(" 配置中增加 "),t("code",[e._v('"modules": false')]),e._v(" 这个配置：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('{\n  "presets": [["env", { "modules": false }]]\n}\n\n')])])]),t("p",[e._v("这样可以把 "),t("code",[e._v("import/export")]),e._v(" 的这一部分模块语法交由 webpack 处理，否则没法使用 Tree shaking 的优化。")]),e._v(" "),t("p",[e._v("有的时候你启用了 Tree shaking 功能，但是发现好像并没有什么用，例如这样一个例子：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// src/component.js\nexport class Person {\n  constructor ({ name }) {\n    this.name = name\n  }\n\n  getName () {\n    return this.name\n  }\n}\n\nexport class Apple {\n  constructor ({ model }) {\n    this.model = model\n  }\n  getModel () {\n    return this.model\n  }\n}\n\n// src/index.js\nimport { Apple } from './components'\n\nconst appleModel = new Apple({\n  model: 'X'\n}).getModel()\n\nconsole.log(appleModel)\n\n")])])]),t("p",[e._v("打包压缩后还是可以发现，"),t("code",[e._v("Person")]),e._v(" 这一块看起来没用到的代码出现在文件中。关于这个问题，详细讲解的话篇幅太长了，建议自行阅读这一篇文章："),t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/32831172",target:"_blank",rel:"noopener noreferrer"}},[e._v("你的Tree-Shaking并没什么卵用"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("这篇文章最近没有更新，但是 uglify 的相关 issue "),t("a",{attrs:{href:"https://github.com/mishoo/UglifyJS2/issues/1261",target:"_blank",rel:"noopener noreferrer"}},[e._v("Class declaration in IIFE considered as side effect"),t("OutboundLink")],1),e._v(" 是有进展的，现在如果你在 Babel 配置中增加 "),t("code",[e._v('"loose": true')]),e._v(" 配置的话，"),t("code",[e._v("Person")]),e._v(" 这一块代码就可以在构建时移除掉了。")]),e._v(" "),t("h2",{attrs:{id:"sideeffects"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sideeffects"}},[e._v("#")]),e._v(" sideEffects")]),e._v(" "),t("p",[e._v("这是 webpack 4.x 才具备的特性，暂时官方还没有比较全面的介绍文档，笔者从 webpack 的 examples 里找到一个东西："),t("a",{attrs:{href:"https://github.com/webpack/webpack/blob/master/examples/side-effects/README.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("side-effects/README.md"),t("OutboundLink")],1),e._v("。")]),e._v(" "),t("p",[e._v("我们拿 "),t("a",{attrs:{href:"https://github.com/lodash/lodash",target:"_blank",rel:"noopener noreferrer"}},[e._v("lodash"),t("OutboundLink")],1),e._v(" 举个例子。有些同学可能对 "),t("a",{attrs:{href:"https://github.com/lodash/lodash",target:"_blank",rel:"noopener noreferrer"}},[e._v("lodash"),t("OutboundLink")],1),e._v(" 已经蛮熟悉了，它是一个工具库，提供了大量的对字符串、数组、对象等常见数据类型的处理函数，但是有的时候我们只是使用了其中的几个函数，全部函数的实现都打包到我们的应用代码中，其实很浪费。")]),e._v(" "),t("p",[e._v("webpack 的 sideEffects 可以帮助解决这个问题。现在 lodash 的 "),t("a",{attrs:{href:"https://www.npmjs.com/package/lodash-es",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES 版本"),t("OutboundLink")],1),e._v(" 的 "),t("code",[e._v("package.json")]),e._v(" 文件中已经有 "),t("code",[e._v("sideEffects: false")]),e._v(" 这个声明了，当某个模块的 "),t("code",[e._v("package.json")]),e._v(" 文件中有了这个声明之后，webpack 会认为这个模块没有任何副作用，只是单纯用来对外暴露模块使用，那么在打包的时候就会做一些额外的处理。")]),e._v(" "),t("p",[e._v("例如你这么使用 "),t("code",[e._v("lodash")]),e._v("：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import { forEach, includes } from 'lodash-es'\n\nforEach([1, 2], (item) => {\n  console.log(item)\n})\n\nconsole.log(includes([1, 2, 3], 1))\n\n")])])]),t("p",[e._v("由于 lodash-es 这个模块的 "),t("code",[e._v("package.json")]),e._v(" 文件有 "),t("code",[e._v("sideEffects: false")]),e._v(" 的声明，所以 webpack 会将上述的代码转换为以下的代码去处理：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import { default as forEach } from 'lodash-es/forEach'\nimport { default as includes } from 'lodash-es/includes'\n\n// ... 其他代码\n\n")])])]),t("p",[e._v("最终 webpack 不会把 lodash-es 所有的代码内容打包进来，只是打包了你用到的那两个方法，这便是 sideEffects 的作用。")]),e._v(" "),t("h2",{attrs:{id:"小结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[e._v("#")]),e._v(" 小结")]),e._v(" "),t("p",[e._v("本小节主要是介绍如何使用 webpack 来进一步控制 JS 文件的大小：")]),e._v(" "),t("ul",[t("li",[e._v("如何在 webpack 中实现按需加载模块")]),e._v(" "),t("li",[e._v("如何利用 webpack 的 Tree shaking 特性")]),e._v(" "),t("li",[e._v("如何利用 webpack 的 sideEffects 特性")])]),e._v(" "),t("p",[e._v("前端资源加载优化的道路还很远，我们前面介绍的这些内容都是 webpack 可以提供给我们的关于这个方面的一些功能，而如何利用好这些功能取决于我们开发者。我们在日常的开发工作中可以多多思考，将更多的前端资源优化加载的思路和 webpack 整合在一起，应用到实践中去。")]),e._v(" "),t("h2",{attrs:{id:"例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[e._v("#")]),e._v(" 例子")]),e._v(" "),t("p",[e._v("本小节提及的一些简单的 Demo 可以在 "),t("a",{attrs:{href:"https://github.com/teabyii/webpack-examples",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack-examples"),t("OutboundLink")],1),e._v(" 找到。")])])}),[],!1,null,null,null);a.default=s.exports}}]);